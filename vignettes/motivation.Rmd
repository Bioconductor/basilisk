---
title: Taming Python versioning within Bioconductor
author: 
- name: Aaron Lun
  email: infinite.monkeys.with.keyboards@gmail.com
date: "Revised: 5 October 2019"
output:
  BiocStyle::html_document:
    toc_float: true
package: jormungandR
bibliography: 
vignette: >
  %\VignetteIndexEntry{Motivation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE)
library(jormungandR)
```

# Why?

Packages like `r CRANpkg("reticulate")` make it easy to use Python modules in our R-based data analyses, allowing us to leverage Python's strengths in fields such as machine learning. 
However, it is notoriously difficult to ensure that a consistent version of Python is available with a consistently versioned set of modules, especially when the system installation of Python is used.
As a result, we cannot easily guarantee that some Python code executed via `r CRANpkg("reticulate")` on one computer will yield the same results as the same code run on another computer.
It is also possible that two R packages depend on incompatible versions of Python modules, such that it is impossible to use both packages at the same time.
These versioning issues represent a major inhibitor on the ability of R/Bioconductor packages to reliably execute Python code across a variety of systems.

# What?

`r Biocpkg("jormungandR")` provides a self-contained Python installation that is fully managed by the Bioconductor installation machinery.
This means that all downstream Bioconductor packages are working with the same version of Python on all systems.
Additionally, `r Biocpkg("jormungandR")` will only install modules from a cohort of pre-defined versions, thus ensuring that the same modules are used by all downstream packages on all systems.
(This cohort is currently defined as the latest version of each package up to the 5th October, 2019.)
Consistency in the execution environment fosters reproducible analysis, simplifies debugging of code and improves interoperability between compliant packages.

# How?

`r Biocpkg("jormungandR")` is primarily intended for developers of R/Bioconductor packages, **not** for end-users.

Consider a downstream package _X_ that depends on, say, `r PyPiLink("scikit-learn")`.
The following code must be executed during installation of _X_.

```{r}
installModules("scikit-learn")
```

This can be done by putting the above line directly into an R source file in the `R/` subdirectory of _X_.
The line will subsequently be evaluated (and the required modules installed) when the R code is executed during _X_'s installation.

Any function in _X_ that depends on the installed modules should call:

```{r}
useBiocPython()
```

This ensures that the Bioconductor-managed instance of Python is used rather than the system installation.

Past this point, we can use standard `r CRANpkg("reticulate")` methods within the relevant function:

```{r}
library(reticulate)
X <- import("sklearn.ensemble")
names(X)
```

# Session information

```{r}
sessionInfo()
```
