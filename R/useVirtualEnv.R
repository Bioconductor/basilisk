#' Set up and use virtual environments
#'
#' Set up and use Python virtual environments for isolated execution of Python code with appropriate versions of all Python packages.
#' 
#' @param envname String containing the name of the virtual environment to create (for \code{setupVirtualEnv}) or use (other functions).
#' @param packages Character vector containing the names of Python packages to install into the virtual environment.
#' It is required to include version numbers in each string.
#' @param pkgpath String specifying the path to the R package installation directory, usually used in an R package installation script.
#' If \code{NULL}, it defaults to \code{\link{virtualenv_root}}.
#' @param pkgname String specifying the package name, if the function is used inside an R package.
#' 
#' @return 
#' \code{setupVirtualEnv} will create a virtual environment - at the designated location if \code{pkgpath} is specified, or at the default location for virtual environments otherwise.
#' It returns a character vector containing \code{packages}.
#'
#' \code{useVirtualEnv} will load the specified virtual environment into the R session.
#' It returns a string specifying the path to the virtual environment.
#' If \code{dry=TRUE}, the character vector is returned without loading the virtual environment.
#'
#' @details
#' Use of virtual environments is the recommended approach for Bioconductor packages to interact with the \pkg{basilisk} Python instance.
#' This avoids version conflicts within an R session when different Bioconductor packages (or even different functions within a single package) require incompatible versions of Python packages.
#'
#' Developers of Bioconductor packages should call \code{setupVirtualEnv} with an appropriate \code{pkgpath} (usually generated by \code{system.file(package=PKGNAME)}) in an \code{.onLoad} function.
#' This will install the relevant Python packages during R package installation (and be skipped 
#' The \pkg{son.of.basilisk} example in the \code{inst} directory of \pkg{basilisk} can be used as an example.
#'
#' @section Dealing with versioning: 
#' Pinned version numbers must be present for all requested packages in \code{packages}.
#' This improved predictability makes debugging much easier when the R package is installed and executed on different systems.
#' Explicit versions are also mandatory for all dependencies of requested packages,
#' which is again necessary to ensure that the same versions are deployed across systems.
#'
#' The only exception to the above rule is for \dQuote{core} packages that are installed into the \pkg{basilisk} Python instance.
#' If your requested packages depend on these core packages, \code{setupVirtualEnv} will automatically install them without requiring them to be listed with explicit version numbers in \code{packages}.
#' A full list of core packages with pinned versions is provided at \code{\link{listCorePackages}}.
#'
#' The exception to the exception occurs when your requested packages are not compatible with the pinned versions of the core packages.
#' In such cases, the compatible versions of the core packages must again be explicitly listed in \code{packages}.
#'
#' @section Wrangling the PYTHONPATH:
#' A side-effect of \code{useVirtualEnv} with \code{dry=FALSE} is that the \code{"PYTHONPATH"} environment variable is unset for the duration of the R session
#' (or \pkg{basilisk} process, depending on the back-end chosen by \code{\link{basiliskStart}}).
#' This is a deliberate choice to avoid compromising the version guarantees if \code{\link{import}} is allowed to search other locations beyond the virtual environment.
#'
#' @author Aaron Lun
#' 
#' @examples
#' setupVirtualEnv('my_package_A', 'pandas==0.25.1')
#' useVirtualEnv("my_package_A")
#' X <- reticulate::import("pandas")
#' X
#' @seealso
#' \code{\link{basiliskStart}}, for how these virtual environments should be used.
#'
#' \code{\link{listCorePackages}}, for a list of core Python packages with pinned versions.
#' @export
#' @importFrom reticulate virtualenv_create virtualenv_install virtualenv_remove
#' virtualenv_root
setupVirtualEnv <- function(envname, packages, pkgpath=NULL) {
    if (!is.null(pkgpath) && file.exists(file.path(pkgpath, "basilisk", envname))) {
        return(NULL)
    }

    versioned <- grepl("==", packages)
    if (!all(versioned)) {
        stop("Python package versions must be explicitly specified")
    }

    # Unsetting this variable, otherwise it seems to override the python=
    # argument in virtualenv_create() (see LTLA/basilisk#1).
    old.retpy <- Sys.getenv("RETICULATE_PYTHON")
    Sys.unsetenv("RETICULATE_PYTHON")
    if (old.retpy!="") {
        on.exit(Sys.setenv(RETICULATE_PYTHON=old.retpy))
    }

    # Use environment variable as this is for testing purposes only,
    # and should not be exposed to the user.
    py.cmd <- Sys.getenv("BASILISK_TEST_PYTHON", useBasilisk())

    # Creating a virtual environment in an appropriate location.
    if (!is.null(pkgpath)) {
        vdir <- file.path(pkgpath, "basilisk")
        dir.create(vdir, recursive=TRUE, showWarnings=FALSE)
        old.work <- Sys.getenv("WORKON_HOME")
        Sys.setenv(WORKON_HOME=vdir)
        on.exit(Sys.setenv(WORKON_HOME=old.work), add=TRUE)
    }

    # ROUND 1: Seeing what the incoming packages need.
    virtualenv_create(envname, python=py.cmd)
    env.cmd <- file.path(normalizePath(virtualenv_root()), envname, "bin", "python3")

    previous <- system2(env.cmd, c("-m", "pip", "freeze"), stdout=TRUE)
    virtualenv_install(envname, packages, ignore_installed=FALSE)
    updated <- system2(env.cmd, c("-m", "pip", "freeze"), stdout=TRUE)

    # If all newly added packages are accounted for, we finish up.
    added <- setdiff(updated, c(previous, packages))
    if (length(added)==0L) {
        return(NULL)
    }

    # Figuring out if any of the newly downloaded packages are core packages.
    # If so, we install them to the base installation if we have access;
    # otherwise, we add it to our virtual environment.
    core.data <- listCorePackages()
    core.pkgs <- core.data$full
    core.names <- core.data$name
    
    added.names <- .full2pkg(added)
    if (any(unlisted.noncore <- !added.names %in% core.names)) {
        stop(sprintf("need to list dependency on '%s'", added[unlisted.noncore][1]))
    }

    virtualenv_remove(envname, confirm=FALSE) # Removing Round 1 to start from a fresh installation.

    if (file.access(system.file(package="basilisk"), 2)==0L) {
        overlaps <- core.names %in% added.names 
        system2(py.cmd, c("-m", "pip", "install", core.pkgs[overlaps]))
        virtualenv_create(envname, python=py.cmd) 
    } else {
        virtualenv_create(envname, python=py.cmd) 
        virtualenv_install(envname, core.packages[overlaps], ignore_installed=FALSE)
    }

    # ROUND 2: Trying again after lazy installation of the core packages.
    previous <- system2(env.cmd, c("-m", "pip", "freeze"), stdout=TRUE)
    virtualenv_install(envname, packages, ignore_installed=FALSE)
    updated <- system2(env.cmd, c("-m", "pip", "freeze"), stdout=TRUE)

    if (any(!updated %in% c(previous, packages))) {
        added <- setdiff(updated, c(previous, packages))
        stop(sprintf("need to list dependency on '%s'", added[1]))
    }

    NULL
}

#' @export
#' @rdname setupVirtualEnv
#' @param dry Logical scalar indicating whether only the directory should be returned without loading the virtual environment.
#' @param required Logical scalar indicating whether an error should be raised if the requested virtual environment cannot be found.
#' @importFrom reticulate use_virtualenv virtualenv_root
useVirtualEnv <- function(envname, pkgname=NULL, dry=FALSE, required=TRUE) {
    old.retpy <- Sys.getenv("RETICULATE_PYTHON")
    Sys.unsetenv("RETICULATE_PYTHON")
    if (old.retpy!="") {
        on.exit(Sys.setenv(RETICULATE_PYTHON=old.retpy))
    }

    if (!is.null(pkgname)) {
        vdir <- system.file("basilisk", package=pkgname, mustWork=TRUE)
    } else {
        vdir <- normalizePath(virtualenv_root())
    }
    vdir <- file.path(vdir, envname)

    if (!dry) {
        # Don't even try to be nice and add an on.exit() clause to protect the
        # global session. This is deliberate; if we're using a virtual
        # environment, and someone tries to import package in the global session,
        # and Python looks somewhere else other than our virtual environment via
        # the PYTHONPATH, we can get the wrong package loaded. 
        Sys.unsetenv("PYTHONPATH")
        use_virtualenv(vdir, required=required)
    }
    vdir
}
