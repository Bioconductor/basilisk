#' Start and stop \pkg{basilisk}-related processes
#'
#' Creates a \pkg{basilisk} process in which Python operations (via \pkg{reticulate}) can be safely performed with the correct versions of Python packages.
#'
#' @param env A \linkS4class{BasiliskEnvironment} object specifying the \pkg{basilisk} environment to use.
#' 
#' Alternatively, a string specifying the path to an environment, though this should only be used for testing purposes.
#' 
#' Alternatively, \code{NULL} to indicate that the base environment of the \pkg{basilisk} Anaconda instance should be used.
#' @param proc A process object generated by \code{basiliskStart}.
#' @param fork Logical scalar indicating whether forking should be performed on non-Windows systems, see \code{\link{getBasiliskFork}}.
#' If \code{FALSE}, a new worker process is created using communication over sockets.
#' @param shared Logical scalar indicating whether \code{basiliskStart} is allowed to load a shared Python instance into the current R process, see \code{\link{getBasiliskShared}}.
#' @param fun A function to be executed in the \pkg{basilisk} process.
#' @param ... Further arguments to be passed to \code{fun}.
#'
#' @return 
#' \code{basiliskStart} returns a process object, the exact nature of which depends on \code{fork} and \code{shared}.
#' This object should only be used in \code{basiliskRun} and \code{basiliskStop}.
#'
#' \code{basiliskRun} returns the output of \code{fun(...)} when executed inside the separate process.
#'
#' \code{basiliskStop} stops the process in \code{proc}.
#' 
#' @details
#' These functions ensure that any Python operations in \code{fun} will use the environment specified by \code{envname}.
#' This avoids version conflicts in the presence of other Python instances or environments loaded by other packages or by the user.
#' Thus, \pkg{basilisk} clients are not affected by (and if \code{shared=FALSE}, do not affect) the activity of other R packages.
#' 
#' If necessary, objects created in \code{fun} can persist across calls to \code{basiliskRun}, e.g., for file handles.
#' This requires the use of \code{\link{assign}} with \code{envir} set to \code{\link{findPersistentEnv}} to persist a variable,
#' and a corresponding \code{\link{get}} to retrieve that object in later calls. 
#' See Examples for more details.
#'
#' It is good practice to call \code{basiliskStop} once computation is finished.
#' This will close the \pkg{basilisk} processes and restore certain environment variables to their original state (e.g., \code{"PYTHONPATH"}) so that other non-\pkg{basilisk} operations can operate properly.
#'
#' Any Python-related operations between \code{basiliskStart} and \code{basiliskStop} should only occur via \code{basiliskRun}.
#' Calling \pkg{reticulate} functions directly will have unpredictable consequences,
#' Similarly, it would be unwise to interact with \code{proc} via any function other than the ones listed here.
#'
#' If \code{proc=NULL} in \code{basiliskRun}, a process will be created and closed automatically.
#' This may be convenient in functions where persistence is not required.
#' Note that doing so requires specification of \code{pkgname} and \code{envname}.
#' 
#' @section Choice of backend:
#' \itemize{
#' \item If \code{shared=TRUE} and no Python version has already been loaded, \code{basiliskStart} will load Python directly into the R session from the specified environment.
#' Similarly, if the existing environment is the same as the requested environment, \code{basiliskStart} will use that directly.
#' This mode is most efficient as it avoids creating any new processes, but the use of a shared Python configuration may prevent non-\pkg{basilisk} packages from working correctly in the same session.
#' \item Otherwise, if \code{fork=TRUE}, no Python version has already been loaded and we are not on Windows, \code{basiliskStart} will create a new process by forking.
#' In the forked process, \code{basiliskStart} will load the specified environment for operations in Python.
#' This is less efficient as it needs to create a new process but it avoids forcing a Python configuration on other packages in the same R session.
#' \item Otherwise, \code{basiliskStart} will create a parallel socket process containing a separate R session.
#' In the new process, \code{basiliskStart} will load the specified environment for Python operations.
#' This is the least efficient as it needs to transfer data over sockets but is guaranteed to work.
#' }
#'
#' Developers can control these choices directly by explicitly specifying \code{shared} and \code{fork},
#' while users can control them indirectly with \code{\link{setBasiliskFork}} and related functions.
#'
#' If the Anaconda installation provided with \pkg{basilisk} satisfies the requirements of the client package,
#' it is strongly recommended to set \code{env=NULL} rather than constructing a separate environment.
#' This is obviously easier but it is also more efficient as it increases the chance of multiple \pkg{basilisk} clients being able to share a common Python instance within the same R session.
#'
#' @section Constraints on user-defined functions:
#' In \code{basiliskRun}, there is no guarantee that \code{fun} has access to the environment in which \code{basiliskRun} is called.
#' This has a number of consequences for the type of code that can be written inside \code{fun}:
#' \itemize{
#' \item Functions or variables from non-base packages used inside \code{fun} should be prefixed with the package namespace, or the package itself should be reloaded inside \code{fun}.
#' \item Any other variables used inside \code{fun} should be explicitly passed as an argument.
#' Developers should not rely on closures to capture variables in the calling environment of \code{basiliskRun}.
#' \item Relevant global variables should be reset inside \code{fun}.
#' \item Developers should \emph{not} attempt to pass complex objects to memory in or out of \code{fun}.
#' This mostly refers to objects that contain custom pointers to memory, e.g., file handles, pointers to \pkg{reticulate} objects.
#' }
#'
#' @section Use of lazy installation:
#' If the specified \pkg{basilisk} environment is not present and \code{env} is a \linkS4class{BasiliskEnvironment} object,
#' the environment will be created upon first use of \code{basiliskStart}.
#' If the Anaconda instance is not present, it will also be installed upon first use of \code{basiliskStart}.
#' The motivation for this is to avoid portability problems with hard-coded paths when \pkg{basilisk} is provided as a binary.
#'
#' Both Anaconda and the environments will be placed in an external user-writable directory,
#' the location of which can be changed by setting the \code{BASILISK_EXTERNAL_DIR} variable.
#' This may occasionally be necessary if the file path to the default location is too long for Windows,
#' or if the default path has spaces that break the Anaconda installer.
#' 
#' Advanced users may consider turning on \code{BASILISK_USE_SYSTEM_DIR} for installations from source,
#' which will place both Anaconda and the environments in the R system directory.
#' This simplifies permission management and avoids duplication in enterprise settings.
#' 
#' @author Aaron Lun
#'
#' @seealso
#' \code{\link{setupBasiliskEnv}}, to set up the conda environments.
#'
#' \code{\link{getBasiliskFork}} and \code{\link{getBasiliskShared}}, to control various global options.
#' 
#' @examples
#' # Loading the base environment:
#' cl <- basiliskStart(NULL)
#' basiliskRun(proc=cl, function() { 
#'     X <- reticulate::import("pandas"); X$`__version__` 
#' })
#' basiliskStop(cl)
#'
#' # Co-exists with our other environment:
#' tmploc <- file.path(tempdir(), "my_package_C")
#' setupBasiliskEnv(tmploc, c('pandas=0.24.1',
#'     "python-dateutil=2.7.1", "pytz=2018.7"))
#' 
#' cl <- basiliskStart(tmploc)
#' basiliskRun(proc=cl, function() { 
#'     X <- reticulate::import("pandas"); X$`__version__` 
#' })
#' basiliskStop(cl)
#'
#' # Persistence of variables is possible within a Start/Stop pair.
#' cl <- basiliskStart(tmploc)
#' basiliskRun(proc=cl, function() {
#'     assign(x="snake.in.my.shoes", 1, envir=basilisk::findPersistentEnv())
#' })
#' basiliskRun(proc=cl, function() {
#'     get("snake.in.my.shoes", envir=basilisk::findPersistentEnv())
#' })
#' basiliskStop(cl)
#'
#' @export
#' @importFrom parallel makePSOCKcluster clusterCall makeForkCluster
#' @importFrom reticulate py_config py_available
basiliskStart <- function(env, fork=getBasiliskFork(), shared=getBasiliskShared()) {
    envpath <- .obtain_env_path(env)

    if (shared && 
        {
            # Seeing if we can just load it successfully.
            old.pypath <- Sys.getenv("PYTHONPATH")
            useBasiliskEnv(envpath, required=FALSE)
        }
    ) {
        proc <- new.env()
        proc$.basilisk.pypath <- old.pypath
    } else {
        if (fork && !isWindows() && (!py_available() || useBasiliskEnv(envpath, dry=TRUE))) { 
            proc <- makeForkCluster(1)
        } else {
            proc <- makePSOCKcluster(1)
        }
        clusterCall(proc, useBasiliskEnv, envpath=envpath)
    }

    proc
}

#' @importFrom basilisk.utils getBasiliskDir installAnaconda getEnvironmentDir
.obtain_env_path <- function(env) {
    base.dir <- getBasiliskDir(assume.installed=FALSE)
    if (!file.exists(base.dir)) {
        installAnaconda()
    }

    if (is.null(env)) {
        return(base.dir)
    }

    envname <- .getEnvName(env)
    pkgname <- .getPkgName(env)

    if (is.null(pkgname)) {
        envpath <- envname
    } else {
        envdir <- getEnvironmentDir(pkgname)
        envpath <- file.path(envdir, envname)

        if (!file.exists(envpath)) {
            setupBasiliskEnv(envpath, packages=.getPackages(env))
        }
    }

    envpath
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel stopCluster
basiliskStop <- function(proc) {
    if (is.environment(proc)) {
        # Restore the old PYTHONPATH.
        Sys.setenv(PYTHONPATH=proc$.basilisk.pypath)
    } else {
        stopCluster(proc)
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel clusterCall
basiliskRun <- function(proc=NULL, fun, ..., env, fork=getBasiliskFork(), shared=getBasiliskShared()) {
    if (is.null(proc)) {
        proc <- basiliskStart(env, fork=fork, shared=shared)
        on.exit(basiliskStop(proc))
    }

    if (is.environment(proc)) {
        # Ensure any 'assign' calls add to 'proc'.
        proc$.basilisk.args <- list(...)
        proc$.basilisk.fun <- fun
        output <- evalq(do.call(.basilisk.fun, .basilisk.args), envir=proc, enclos=proc)
        rm(".basilisk.args", envir=proc)
        rm(".basilisk.fun", envir=proc)
    } else {
        output <- clusterCall(proc, fun=fun, ...)[[1]]
    } 

    output
}
