#' Start and stop \pkg{basilisk}-related processes
#'
#' Creates a \pkg{basilisk} process in which Python operations (via \pkg{reticulate}) can be safely performed with the correct versions of Python packages.
#'
#' @inheritParams setupVirtualEnv
#' @param envname String containing the name of the virtual environment to use.
#' @param proc A process object generated by \code{basiliskStart}.
#' @param fork Logical scalar indicating whether forking should be performed on non-Windows systems, see \code{\link{getBasiliskFork}}.
#' If \code{FALSE}, a new worker process is created using communication over sockets.
#' @param global Logical scalar indicating whether \code{basiliskStart} is allowed to load a Python instance into the current R process, 
#' see \code{\link{getBasiliskGlobal}}.
#' @param fun A function to be executed in the \pkg{basilisk} process.
#' @param ... Further arguments to be passed to \code{fun}.
#'
#' @return 
#' \code{basiliskStart} returns a process object, the exact nature of which depends on \code{fork} and \code{global}.
#' This object should only be used in \code{basiliskRun} and \code{basiliskStop}.
#'
#' \code{basiliskRun} returns the output of \code{fun(...)} when executed inside the separate process.
#'
#' \code{basiliskStop} stops the process in \code{proc}.
#' 
#' @details
#' These functions ensure that any Python operations in \code{fun} are guaranteed to use the virtual environment specified by \code{envname}.
#' This avoids version conflicts in the presence of other Python instances or virtual environments loaded by other packages or by the user.
#' Thus, \pkg{basilisk}-powered R packages are not affected by (and if \code{global=FALSE}, do not affect) the activity of other R packages.
#' 
#' If necessary, objects created in \code{fun} can persist across calls to \code{basiliskRun}, e.g., for file handles.
#' This requires the use of \code{\link{assign}} with \code{envir=parent.frame()} to set a persistent object,
#' and a corresponding \code{\link{get}} to retrieve that object in later calls. 
#' See Examples for more details.
#'
#' It is good practice to call \code{basiliskStop} once computation is finished.
#' This will close the \pkg{basilisk} processes and restore certain environment variables to their original state (e.g., \code{"PYTHONPATH"}) so that other non-\pkg{basilisk} operations can operate properly.
#'
#' Any Python-related operations between \code{basiliskStart} and \code{basiliskStop} should only occur via \code{basiliskRun}.
#' Calling \pkg{reticulate} functions directly will have unpredictable consequences,
#' Similarly, it would be unwise to interact with \code{proc} via any function other than the ones listed here.
#'
#' If \code{proc=NULL} in \code{basiliskRun}, a process will be created and closed automatically.
#' This may be convenient in functions where persistence is not required.
#' Note that doing so requires specification of \code{pkgname} and \code{envname}.
#' 
#' @section Choice of backend:
#' \itemize{
#' \item If \code{global=TRUE} and no Python version has already been loaded, \code{basiliskStart} will load Python directly into the R session from the specified virtual environment.
#' Similarly, if the existing virtual environment is the same as the requested environment, \code{basiliskStart} will use that directly.
#' This mode is most efficient as it avoids creating any new processes, but the use of a global Python configuration may prevent non-\pkg{basilisk} packages from working correctly in the same session.
#' \item Otherwise, if \code{fork=TRUE}, no Python version has already been loaded and we are not on Windows, \code{basiliskStart} will create a new process by forking.
#' In the forked process, \code{basiliskStart} will load the specified virtual environment for operations in Python.
#' This is less efficient as it needs to create a new process but it avoids forcing a Python configuration on other packages in the same R session.
#' \item Otherwise, \code{basiliskStart} will create a parallel socket process containing a separate R session.
#' In the new process, \code{basiliskStart} will load the specified virtual environment for Python operations.
#' This is the least efficient as it needs to transfer data over sockets but is guaranteed to work.
#' }
#' Developers can control these choices directly by explicitly specifying \code{global} or \code{fork},
#' while users can control them indirectly with \code{\link{setBasiliskFork}} and \code{\link{setBasiliskGlobal}}.
#'
#' @section Function definition:
#' In \code{basiliskRun}, there is no guarantee that \code{fun} has access to the environment in which \code{basiliskRun} is called.
#' This has a number of consequences for the type of code that can be written inside \code{fun}:
#' \itemize{
#' \item Functions or variables from non-base packages used inside \code{fun} should be prefixed with the package namespace, or the package itself should be reloaded inside \code{fun}.
#' \item Any other variables used inside \code{fun} should be explicitly passed as an argument.
#' Developers should not rely on closures to capture variables in the calling environment of \code{basiliskRun}.
#' \item Relevant global variables should be reset inside \code{fun}.
#' \item Developers should not attempt to pass complex objects to memory in or out of \code{fun}.
#' This mostly refers to objects that contain custom pointers to memory, e.g., file handles.
#' }
#' 
#' @author Aaron Lun
#'
#' @seealso
#' \code{\link{setupVirtualEnv}}, to set up the virtual environments.
#'
#' \code{\link{getBasiliskFork}} and \code{\link{getBasiliskGlobal}}, to control the forking and global setting behavior respectively.
#' 
#' @examples
#' # Loading one virtual environment into our R session:
#' setupVirtualEnv('my_package_A', c('pandas==0.25.1',
#'     "python-dateutil==2.8.1", "pytz==2019.3"))
#' useVirtualEnv("my_package_A")
#' X <- reticulate::import("pandas")
#' X$`__version__` 
#'
#' # Co-exists with our other virtual environment in a separate process:
#' setupVirtualEnv('my_package_B', c('pandas==0.24.1',
#'     "python-dateutil==2.7.1", "pytz==2017.2"))
#' 
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     X <- reticulate::import("pandas"); X$`__version__` 
#' })
#' basiliskStop(cl)
#'
#' # Persistence is possible.
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     assign(x="snake.in.my.shoes", 1, envir=parent.frame())
#' })
#' basiliskRun(proc=cl, function() {
#'     get("snake.in.my.shoes", envir=parent.frame())
#' })
#' basiliskStop(cl)
#' 
#' @export
#' @importFrom parallel makePSOCKcluster clusterCall makeForkCluster
#' @importFrom reticulate py_config py_available
basiliskStart <- function(envname, pkgname=NULL, fork=getBasiliskFork(), global=getBasiliskGlobal()) {
    if (global && 
        {
            # Seeing if we can just load it successfully.
            old.pypath <- Sys.getenv("PYTHONPATH")
            requested <- useVirtualEnv(envname, pkgname=pkgname, required=FALSE)
            identical(requested, py_config()$virtualenv)
        }) 
    {
        proc <- new.env()
        proc$.basilisk.pypath <- old.pypath
        proc
    } else {
        if (fork && .Platform$OS.type!="windows" && 
            (!py_available() ||
                identical(useVirtualEnv(envname, pkgname=pkgname, dry=TRUE), py_config()$virtualenv)
            ))
        { 
            proc <- makeForkCluster(1)
        } else {
            proc <- makePSOCKcluster(1)
        }
        clusterCall(proc, useVirtualEnv, envname=envname, pkgname=pkgname)
        proc 
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel stopCluster
basiliskStop <- function(proc) {
    if (is.environment(proc)) {
        # Restore the old PYTHONPATH.
        Sys.setenv(PYTHONPATH=proc$.basilisk.pypath)
    } else {
        stopCluster(proc)
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel clusterCall
basiliskRun <- function(proc=NULL, fun, ..., envname, pkgname=NULL, fork=getBasiliskFork(), global=getBasiliskGlobal()) {
    if (is.null(proc)) {
        proc <- basiliskStart(envname, pkgname=pkgname, fork=fork, global=global)
        on.exit(basiliskStop(proc))
    }
    if (is.environment(proc)) {
        # Ensure any 'assign' calls add to 'proc'.
        proc$.basilisk.args <- list(...)
        proc$.basilisk.fun <- fun
        output <- evalq(do.call(.basilisk.fun, .basilisk.args), envir=proc, enclos=proc)
        rm(".basilisk.args", envir=proc)
        rm(".basilisk.fun", envir=proc)
        output
    } else {
        clusterCall(proc, fun=fun, ...)[[1]]
    }
}
