#' Start and stop \pkg{basilisk}-related processes
#'
#' Creates a \pkg{basilisk} process in which Python operations (via \pkg{reticulate}) can be safely performed with the correct versions of Python packages.
#'
#' @inheritParams setupVirtualEnv
#' @param envname String containing the name of the virtual environment to use.
#' @param proc A process object generated by \code{basiliskStart}.
#' @param fork Logical scalar indicating whether forking should be performed on non-Windows systems, see \code{\link{getBasiliskFork}}.
#' If \code{FALSE}, a new worker process is created using communication over sockets.
#' @param shared Logical scalar indicating whether \code{basiliskStart} is allowed to load a shared Python instance into the current R process, see \code{\link{getBasiliskShared}}.
#' @param persist Logical scalar indicating whether a persistent process should be created, see \code{\link{getBasiliskPersist}}.
#' @param fun A function to be executed in the \pkg{basilisk} process.
#' @param ... Further arguments to be passed to \code{fun}.
#'
#' @return 
#' \code{basiliskStart} returns a process object, the exact nature of which depends on \code{fork}, \code{shared} and \code{persist}.
#' This object should only be used in \code{basiliskRun} and \code{basiliskStop}.
#'
#' \code{basiliskRun} returns the output of \code{fun(...)} when executed inside the separate process.
#'
#' \code{basiliskStop} stops the process in \code{proc}.
#' 
#' @details
#' These functions ensure that any Python operations in \code{fun} are guaranteed to use the virtual environment specified by \code{envname}.
#' This avoids version conflicts in the presence of other Python instances or virtual environments loaded by other packages or by the user.
#' Thus, \pkg{basilisk}-powered R packages are not affected by (and if \code{shared=FALSE}, do not affect) the activity of other R packages.
#' 
#' If necessary, objects created in \code{fun} can persist across calls to \code{basiliskRun}, e.g., for file handles.
#' This requires the use of \code{\link{assign}} with \code{envir=parent.frame()} to set a persistent object,
#' and a corresponding \code{\link{get}} to retrieve that object in later calls. 
#' See Examples for more details.
#'
#' It is good practice to call \code{basiliskStop} once computation is finished.
#' This will close the \pkg{basilisk} processes and restore certain environment variables to their original state (e.g., \code{"PYTHONPATH"}) so that other non-\pkg{basilisk} operations can operate properly.
#'
#' Any Python-related operations between \code{basiliskStart} and \code{basiliskStop} should only occur via \code{basiliskRun}.
#' Calling \pkg{reticulate} functions directly will have unpredictable consequences,
#' Similarly, it would be unwise to interact with \code{proc} via any function other than the ones listed here.
#'
#' If \code{proc=NULL} in \code{basiliskRun}, a process will be created and closed automatically.
#' This may be convenient in functions where persistence is not required.
#' Note that doing so requires specification of \code{pkgname} and \code{envname}.
#' 
#' @section Choice of backend:
#' \itemize{
#' \item If \code{shared=TRUE} and no Python version has already been loaded, \code{basiliskStart} will load Python directly into the R session from the specified virtual environment.
#' Similarly, if the existing virtual environment is the same as the requested environment, \code{basiliskStart} will use that directly.
#' This mode is most efficient as it avoids creating any new processes, but the use of a shared Python configuration may prevent non-\pkg{basilisk} packages from working correctly in the same session.
#' \item Otherwise, if \code{fork=TRUE}, no Python version has already been loaded and we are not on Windows, \code{basiliskStart} will create a new process by forking.
#' In the forked process, \code{basiliskStart} will load the specified virtual environment for operations in Python.
#' This is less efficient as it needs to create a new process but it avoids forcing a Python configuration on other packages in the same R session.
#' \item Otherwise, \code{basiliskStart} will create a parallel socket process containing a separate R session.
#' In the new process, \code{basiliskStart} will load the specified virtual environment for Python operations.
#' This is the least efficient as it needs to transfer data over sockets but is guaranteed to work.
#' }
#' Developers can control these choices directly by explicitly specifying \code{global} or \code{fork},
#' while users can control them indirectly with \code{\link{setBasiliskFork}} and \code{\link{setBasiliskGlobal}}.
#'
#' @section Constraints on user-defined functions:
#' In \code{basiliskRun}, there is no guarantee that \code{fun} has access to the environment in which \code{basiliskRun} is called.
#' This has a number of consequences for the type of code that can be written inside \code{fun}:
#' \itemize{
#' \item Functions or variables from non-base packages used inside \code{fun} should be prefixed with the package namespace, or the package itself should be reloaded inside \code{fun}.
#' \item Any other variables used inside \code{fun} should be explicitly passed as an argument.
#' Developers should not rely on closures to capture variables in the calling environment of \code{basiliskRun}.
#' \item Relevant global variables should be reset inside \code{fun}.
#' \item Developers should not attempt to pass complex objects to memory in or out of \code{fun}.
#' This mostly refers to objects that contain custom pointers to memory, e.g., file handles.
#' }
#' 
#' @author Aaron Lun
#'
#' @seealso
#' \code{\link{setupVirtualEnv}}, to set up the virtual environments.
#'
#' \code{\link{getBasiliskFork}} and \code{\link{getBasiliskShared}}, to control various global options.
#' 
#' @examples
#' # Loading one virtual environment into our R session:
#' setupVirtualEnv('my_package_A', c('pandas==0.25.3',
#'     "python-dateutil==2.8.1", "pytz==2019.3"))
#' useVirtualEnv("my_package_A")
#' X <- reticulate::import("pandas")
#' X$`__version__` 
#'
#' # Co-exists with our other virtual environment in a separate process:
#' setupVirtualEnv('my_package_B', c('pandas==0.24.1',
#'     "python-dateutil==2.7.1", "pytz==2017.2"))
#' 
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     X <- reticulate::import("pandas"); X$`__version__` 
#' })
#' basiliskStop(cl)
#'
#' # Persistence is possible.
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     assign(x="snake.in.my.shoes", 1, envir=parent.frame())
#' })
#' basiliskRun(proc=cl, function() {
#'     get("snake.in.my.shoes", envir=parent.frame())
#' })
#' basiliskStop(cl)
#' 
#' @export
#' @importFrom parallel makePSOCKcluster clusterCall makeForkCluster
#' @importFrom reticulate py_config py_available
basiliskStart <- function(envname, pkgname=NULL, 
    fork=getBasiliskFork(), shared=getBasiliskShared(), persist=getBasiliskPersist())
{
    if (persist) {
        available <- .get_persist(envname, pkgname)
        if (!is.null(available)) {
            return(available)
        }
    }

    if (shared && 
        {
            # Seeing if we can just load it successfully.
            old.pypath <- Sys.getenv("PYTHONPATH")
            requested <- useVirtualEnv(envname, pkgname=pkgname, required=FALSE)
            identical(requested, py_config()$virtualenv)
        }) 
    {
        proc <- new.env()
        proc$.basilisk.pypath <- old.pypath
    } else {
        if (fork && .Platform$OS.type!="windows" && 
            (!py_available() ||
                identical(useVirtualEnv(envname, pkgname=pkgname, dry=TRUE), py_config()$virtualenv)
            ))
        { 
            proc <- makeForkCluster(1)
        } else {
            proc <- makePSOCKcluster(1)
        }
        clusterCall(proc, useVirtualEnv, envname=envname, pkgname=pkgname)

        if (persist) {
            .set_persist(envname, pkgname, proc)
            proc <- list(envname=envname, pkgname=pkgname, fork=fork)
        }
    }

    proc
}

.create_persist_key <- function(envname, pkgname) paste0(envname, "_", pkgname)

.get_persist <- function(envname, pkgname) {
    key <- .create_persist_key(envname, pkgname)
    getOption("basilisk.persist.values", list())[[key]]
}

.set_persist <- function(envname, pkgname, proc) {
    key <- .create_persist_key(envname, pkgname)
    available <- getOption("basilisk.persist.values", list())
    available[[key]] <- proc
    options(basilisk.persist.values=available)
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel stopCluster
basiliskStop <- function(proc) {
    if (is.environment(proc)) {
        # Restore the old PYTHONPATH.
        Sys.setenv(PYTHONPATH=proc$.basilisk.pypath)
    } else if (is(proc, "cluster")) {
        stopCluster(proc)
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel clusterCall
basiliskRun <- function(proc=NULL, fun, ..., envname, pkgname=NULL, 
    fork=getBasiliskFork(), shared=getBasiliskShared(), persist=getBasiliskPersist())
{
    if (is.null(proc)) {
        proc <- basiliskStart(envname, pkgname=pkgname, fork=fork, shared=shared, persist=persist)
        on.exit(basiliskStop(proc))
    }

    if (is.environment(proc)) {
        # Ensure any 'assign' calls add to 'proc'.
        proc$.basilisk.args <- list(...)
        proc$.basilisk.fun <- fun
        output <- evalq(do.call(.basilisk.fun, .basilisk.args), envir=proc, enclos=proc)
        rm(".basilisk.args", envir=proc)
        rm(".basilisk.fun", envir=proc)
    } else if (is(proc, "cluster")) {
        output <- clusterCall(proc, fun=fun, ...)[[1]]
    } else {
        proc2 <- .get_persist(envname=proc$envname, pkgname=proc$pkgname)

        # Safety measure in case the process failed or something;
        # we force it to create a new persistent process.
        test <- try(clusterCall(proc2, fun=identity, x=1), silent=TRUE)
        if (is(test, "try-error")) {
            .set_persist(proc$envname, proc$pkgname, NULL)
            proc2 <- basiliskStart(proc$envname, pkgname=proc$pkgname, fork=proc$fork, shared=FALSE, persist=TRUE)
        }

        output <- clusterCall(proc2, fun=fun, ...)[[1]]
    }

    output
}
