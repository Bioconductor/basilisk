#' Start and stop \pkg{basilisk}-related processes
#'
#' Creates a \pkg{basilisk} process in which Python operations (via \pkg{reticulate}) can be safely performed with the correct versions of Python packages.
#'
#' @inheritParams setupVirtualEnv
#' @param envname String containing the name of the virtual environment to use.
#' @param proc A process object generated by \code{basiliskStart}.
#' @param fork Logical scalar indicating whether forking should be performed on non-Windows systems, see \code{\link{getBasiliskFork}}.
#' If \code{FALSE}, a new worker process is created using communication over sockets.
#' @param global Logical scalar indicating whether \code{basiliskStart} is allowed to load a Python instance into the current R process, 
#' see \code{\link{getBasiliskGlobal}}.
#' @param fun A function to be executed in the \pkg{basilisk} process.
#' @param ... Further arguments to be passed to \code{fun}.
#'
#' @return 
#' \code{basiliskStart} returns a process object, the exact nature of which depends on \code{fork} and \code{global}.
#' This object should only be used in \code{basiliskRun} and \code{basiliskStop}.
#'
#' \code{basiliskRun} returns the output of \code{fun(...)} when executed inside the separate process.
#'
#' \code{basiliskStop} stops the process in \code{proc}.
#' 
#' @details
#' These functions ensure that any Python operations in \code{fun} are guaranteed to use the virtual environment specified by \code{envname}.
#' This avoids version conflicts in the presence of other Python instances or virtual environments loaded by other packages or by the user.
#' Thus, \pkg{basilisk}-powered R packages are not affected by (and if \code{global=FALSE}, do not affect) the activity of other R packages.
#' 
#' If necessary, objects created in \code{fun} can persist across calls to \code{basiliskRun}, e.g., for file handles.
#' This requires the use of \code{\link{assign}} with \code{envir=parent.frame()} to set a persistent object,
#' and a corresponding \code{\link{get}} to retrieve that object in later calls. 
#' See Examples for more details.
#'
#' It is good practice to call \code{\link{basiliskStop}} once computation is finished and persistence is no longer required.
#'
#' If \code{proc=NULL} in \code{basiliskRun}, a process will be created and closed automatically.
#' This may be convenient in functions where persistence is not required.
#' Note that doing so requires specification of \code{pkgname} and \code{envname}.
#' 
#' @author Aaron Lun
#'
#' @seealso
#' \code{\link{setupVirtualEnv}}, to set up the virtual environments.
#'
#' \code{\link{getBasiliskFork}} and \code{\link{getBasiliskGlobal}}, to control the forking and global setting behavior respectively.
#' 
#' @examples
#' # Loading one virtual environment into our R session:
#' setupVirtualEnv('my_package_A', 'pandas==0.25.1')
#' useVirtualEnv("my_package_A")
#' X <- reticulate::import("pandas")
#' X$`__version__` 
#'
#' # Co-exists with our other virtual environment in a separate process:
#' setupVirtualEnv('my_package_B', 'pandas==0.24.1')
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     X <- reticulate::import("pandas"); X$`__version__` 
#' })
#' basiliskStop(cl)
#'
#' # Persistence is possible.
#' cl <- basiliskStart('my_package_B')
#' basiliskRun(proc=cl, function() { 
#'     assign(x="snake.in.my.shoes", 1, envir=parent.frame())
#' })
#' basiliskRun(proc=cl, function() {
#'     get("snake.in.my.shoes", envir=parent.frame())
#' })
#' basiliskStop(cl)
#' 
#' @export
#' @importFrom parallel makePSOCKcluster clusterCall makeForkCluster
#' @importFrom reticulate py_config py_available
basiliskStart <- function(envname, pkgname=NULL, fork=getBasiliskFork(), global=getBasiliskGlobal()) {
    if (global && 
        {
            # Seeing if we can just load it successfully.
            requested <- useVirtualEnv(envname, pkgname=pkgname, required=FALSE)
            identical(requested, py_config()$virtualenv)
        }) 
    {
        new.env()
    } else {
        if (fork && .Platform$OS.type!="windows" && 
            (!py_available() ||
                identical(useVirtualEnv(envname, pkgname=pkgname, dry=TRUE), py_config()$virtualenv)
            ))
        { 
            proc <- makeForkCluster(1)
        } else {
            proc <- makePSOCKcluster(1)
        }
        clusterCall(proc, useVirtualEnv, envname=envname, pkgname=pkgname)
        proc 
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel stopCluster
basiliskStop <- function(proc) {
    if (!is.environment(proc)) {
        stopCluster(proc)
    }
}

#' @export
#' @rdname basiliskStart
#' @importFrom parallel clusterCall
basiliskRun <- function(proc=NULL, fun, ..., envname, pkgname=NULL, fork=getBasiliskFork(), global=getBasiliskGlobal()) {
    if (is.null(proc)) {
        proc <- basiliskStart(envname, pkgname=pkgname, fork=fork, global=global)
        on.exit(basiliskStop(proc))
    }
    if (is.environment(proc)) {
        # Ensure any 'assign' calls add to 'proc'.
        proc$.basilisk.args <- list(...)
        output <- evalq(do.call(fun, .basilisk.args), envir=proc, enclos=proc)
        rm(".basilisk.args", envir=proc)
        output
    } else {
        clusterCall(proc, fun=fun, ...)[[1]]
    }
}
