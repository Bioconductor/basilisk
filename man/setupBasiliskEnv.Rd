% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setupBasiliskEnv.R
\name{setupBasiliskEnv}
\alias{setupBasiliskEnv}
\title{Set up a \pkg{basilisk} environments}
\usage{
setupBasiliskEnv(envpath, packages, pip = NULL)
}
\arguments{
\item{envpath}{String containing the path to the environment to use.}

\item{packages}{Character vector containing the names of conda packages to install into the environment.
Version numbers must be included.}

\item{pip}{Character vector containing the names of additional packages to install from PyPi using pip.
Version numbers must be included.}
}
\value{
A conda environment is created at \code{envpath} containing the specified \code{packages}.
The function will return a logical scalar indicating whether creation was performed,
which will be \code{FALSE} if the environment already exists.
}
\description{
Set up a Python conda environment for isolated execution of Python code with appropriate versions of all Python packages.
}
\details{
\pkg{basilisk} environments are simply Python conda environments that are created and managed by \pkg{basilisk}.
Each \pkg{basilisk} environment can contain different Python packages with different versions,
allowing us to avoid version conflicts within an R session when different Bioconductor packages (or even different functions within a single package) require incompatible versions of Python packages.

Developers of client packages should never need to call this function directly.
For typical usage, \code{setupBasiliskEnv} is automatically called by \code{\link{basiliskStart}} to perform lazy installation.
Developers should also create \code{configure(.win)} files to call \code{\link{configureBasiliskEnv}},
which will call \code{setupBasiliskEnv} during R package installation when \code{BASILISK_USE_SYSTEM_DIR} is set.

If a \pkg{basilisk} environment is already present at \code{envpath}, \code{setupBasiliskEnv} is a no-op.
This ensures that the function only installs the packages once.
}
\section{Versioning}{

Pinned version numbers must be present for all requested conda packages in \code{packages}.
This improved predictability makes debugging much easier when the R package is installed and executed on different systems.
Note that this refers to conda packages, not Python packages, where the version notation for the former uses a single \code{=};
any \code{==} will be coerced to \code{=} automatically.

It is possible to use the \code{pip} argument to install additional packages from PyPi after all the conda packages are installed.
All packages listed here are also expected to have pinned versions, this time using the \code{==} notation.
However, some caution is required when mixing packages from conda and pip,
see \url{https://www.anaconda.com/using-pip-in-a-conda-environment} for more details.

It is also good practice to explicitly list the versions of the dependencies of all desired packages.
This protects against future changes in the behavior of your code if conda's dependency resolver defaults to a different version of a required package.
We suggest using \code{conda env export} to identify relevant dependencies and include them in \code{packages};
the only reason that pinned dependencies are not mandatory is because some dependencies are OS-specific,
requiring some manual pruning of the output of \code{conda env export}.

It is possible to specify a different version of Python in \code{packages} by supplying, e.g., \code{"python=2.7.10"}.
If no Python version is listed, the version in the Anaconda installation is used by default.
}

\examples{
tmploc <- file.path(tempdir(), "my_package_A")
setupBasiliskEnv(tmploc, c('pandas=0.25.3',
    "python-dateutil=2.8.1", "pytz=2019.3"))

}
\seealso{
\code{\link{listCorePackages}}, for a list of core Python packages with pinned versions.
}
